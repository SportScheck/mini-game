class Background {
	constructor(image, speed, x, y) {
		this.x = x;
		this.y = y;
		this.image = image;
		this.speed = speed; // Redefine speed of the background for panning
	}

	draw() {
		// Pan background
		this.x -= this.speed;
		gameArea.context.drawImage(this.image, this.x , this.y);

    gameArea.context.drawImage(this.image, this.x + this.image.width, this.y);
		// If the image scrolled off the screen, reset
		if (Math.abs(this.x) >= this.image.width)
			this.x = 0;
	}
}

const RUNNER_HEIGHT = 72;
const RUNNER_WIDTH = 40;
const RUNNER_SPEED = 8;
const JUMP_TIME = 130;

class Runner {
  constructor(image, level) {
    this.level = level;
    this.image = image;
    this.frameWidth = RUNNER_WIDTH;
    this.frameHeight = RUNNER_HEIGHT;
    this.endFrame = 3;
    this.frameSpeed = RUNNER_SPEED;
    this.framesPerRow = Math.floor(this.image.width / this.frameWidth);
    this.currentFrame = 0;
    this.counter = 0;
    this.jumpCounter = JUMP_TIME;
    this.jumpTime = JUMP_TIME;
    this.dy        = 0;
    this.isFalling = false;
    this.isJumping = false;
    this.isCrashed = false;
    this.x = 60;
    this.y = 220;

    this.increaseLevel = false;

    const self = this;

    window.addEventListener('keydown', function(e) {
      if (e.keyCode === 32 && !self.isFalling) {
        self.isJumping = true;
      }
    });
    window.addEventListener('touchstart', function(e) {
      if(!self.isFalling) {
        self.isJumping = true;
      }
    });
  }

  nextLevel(level) {
    this.level = level;
    this.increaseLevel = true;
  }

  updateLevel() {
    this.jumpTime = JUMP_TIME - this.level * 10;
    this.jumpCounter = this.jumpTime;
  }

  jump() {
    if (this.isJumping) {
      this.dy -= this.calculateHeightChange(this.jumpTime - this.jumpCounter);
      this.jumpCounter--;
    }

    if (this.isFalling) {
      this.dy -= this.calculateHeightChange(this.jumpTime - this.jumpCounter);
      this.jumpCounter--;
    }

    if (this.jumpCounter === this.jumpTime / 2) {
      this.isJumping = false;
      this.isFalling = true;
    }

    if (this.jumpCounter === 0) {
      this.isFalling = false;
      this.jumpCounter = this.jumpTime;
    }
  }

  update() {
    // update to the next frame if it is time
    if (this.counter == (this.frameSpeed - 1)) {
      this.currentFrame = (this.currentFrame + 1) % this.endFrame;
    }

    // update the counter
    this.counter = (this.counter + 1) % this.frameSpeed;
  };

  runningAnim(col, row, frameWidth, frameHeight, x, y) {
    gameArea.context.drawImage(
       this.image,
       col * frameWidth, row * frameHeight,
       frameWidth, frameHeight,
       x, y + this.dy,
       frameWidth, frameHeight);
  };

  jumpingAnim(col, row, frameWidth, frameHeight, x, y) {
    gameArea.context.drawImage(
       this.image,
       frameWidth, 0,
       frameWidth, frameHeight,
       x, y + this.dy,
       frameWidth, frameHeight);
  };

  crashAnim(col, row, frameWidth, frameHeight, x, y) {
    gameArea.context.drawImage(
       this.image,
       frameWidth * 3, 0,
       frameWidth, frameHeight,
       x, y + this.dy,
       frameWidth, frameHeight);
  };

  crash() {
    this.isCrashed = true;
  }

  reset() {
    this.isCrashed = false;
    this.isJumping = false;
    this.isFalling = false;
    this.dy        = 0;
    this.currentFrame = 0;
    this.counter = 0;
    this.jumpTime = JUMP_TIME - level * 15;
    this.jumpCounter = this.jumpTime;
  }

  draw() {
      // get the row and col of the frame
      const row = Math.floor(this.currentFrame / this.framesPerRow);
      const col = Math.floor(this.currentFrame % this.framesPerRow);

      this.jump();

      if (this.isCrashed) {
        this.crashAnim(col, row, this.frameWidth, this.frameHeight, this.x, this.y)
      } else if (this.isJumping || this.isFalling) {
        this.jumpingAnim(col, row, this.frameWidth, this.frameHeight, this.x, this.y);
      } else {
        if (this.increaseLevel) {
          this.updateLevel();
          this.increaseLevel = false;
        }
        this.runningAnim(col, row, this.frameWidth, this.frameHeight, this.x, this.y);
      }
  };

  calculateHeightChange(time) {
    let oldHeight = - 450 * Math.pow((time/this.jumpTime - 0.5), 2);
    let newHeight = - 450 * Math.pow(((time + 1)/this.jumpTime - 0.5), 2);
    return newHeight - oldHeight;
  }
}

const OBSTACLE_HEIGHT = 60;
const OBSTACLE_WIDTH = 52;
const OBSTACLE_SPEED = 8;

class Obstacle {
	constructor(image, speed) {
    this.image = image;
    this.frameWidth = OBSTACLE_WIDTH;
    this.frameHeight = OBSTACLE_HEIGHT;
    this.endFrame = 4;
    this.frameSpeed = OBSTACLE_SPEED;
    this.framesPerRow = Math.floor(this.image.width / this.frameWidth);
    this.currentFrame = 0;
    this.counter = 0;
		this.x = 600;
		this.y = 230;
		this.speed = speed; // Redefine speed of the background for panning
	}

  update() {
    // update to the next frame if it is time
    if (this.counter == (this.frameSpeed - 1)) {
      this.currentFrame = (this.currentFrame + 1) % this.endFrame;
    }

    // update the counter
    this.counter = (this.counter + 1) % this.frameSpeed;
  };


	draw() {
    if (this.x < -this.image.width) return;
		// Pan background
		this.x -= this.speed;

    const row = Math.floor(this.currentFrame / this.framesPerRow);
    const col = Math.floor(this.currentFrame % this.framesPerRow);

    gameArea.context.drawImage(
       this.image,
       col * this.frameWidth, row * this.frameHeight,
       this.frameWidth, this.frameHeight,
       this.x, this.y,
       this.frameWidth, this.frameHeight);
	}
}

const SCORE_FONT = '"Press Start 2P"';
const SCORE_SIZE = 0.003;
const HEADLINE_SIZE = 0.006;
const SPACE = 40;

class Score {
  constructor() {
     this.font = SCORE_FONT;
     this.size = SCORE_SIZE * gameArea.x;
     this.headlineSize = HEADLINE_SIZE * gameArea.x;
     this.speed = 3;
     this.color = 'black';
     this.distance = 0;
     this.calories = 0;
     this.x = gameArea.x / 2;
     this.y = 40;
   }

  update() {
    const ctx = gameArea.context;

    this.distance = parseInt((gameArea.frameNo / 50) * this.speed);

    const text = 'GELAUFENE STRECKE: ' + this.distance + 'M';

    ctx.font = this.size + 'rem' + ' ' + this.font;
    ctx.fillStyle = this.color;
    ctx.textAlign="center";
    ctx.fillText(text, this.x, this.y);
  }

  done() {
    const ctx = gameArea.context;

    this.calories = parseInt((gameArea.frameNo / 50) * 0.2);

    // text blocks
    const text = 'G A M E  O V E R';
    const text2 = 'DU HAST ' + this.calories + ' KCAL VERBRANNT!';
    const text3 = 'STARTEN & SPRINGEN';
    const text4 = 'MIT LEERTASTE'

    // text positions
    const positionYText = SPACE * 2.5;
    const positionYText2 = SPACE * 3.5;
    const positionYText3 = SPACE * 4.5;
    const positionYText4 = SPACE * 5;

    // general text style
    ctx.fillStyle = this.color;
    ctx.textAlign = 'center';

    // define size and set headline on canvas
    ctx.font = this.headlineSize + 'rem' + ' ' + this.font;
    ctx.fillText(text, this.x, positionYText);

    // define size and set text on canvas
    ctx.font = this.size + 'rem' + ' ' + this.font;
    ctx.fillText(text2, this.x, positionYText2);
    ctx.fillText(text3, this.x, positionYText3);
    ctx.fillText(text4, this.x, positionYText4);
  }
}

let myReq;
let isCrashed = false;
let splashScreen = false;
let initalStart = true;
let level = 0;
const GROUND_SPEED = 2;
let obstacleSpeed = GROUND_SPEED;

const gameArea = {
  canvas: document.getElementById('minigame'),
  prestart: function() {
  },
  start: function() {
    setCanvasWidth('initial');
    this.context = this.canvas.getContext('2d');
    this.frameNo = 0;
    this.canvas.classList.add('minigame--started');
  },
  stop: function() {
    window.cancelAnimationFrame(myReq);
  }
}

function setCanvasWidth(type) {
  const clientWidth = document.getElementsByClassName('minigame-container')[0].clientWidth;
  const maxWidth = 600;
  const newCanvasWidth = clientWidth < maxWidth ? clientWidth : maxWidth;

  gameArea.canvas.width = newCanvasWidth;
  gameArea.x = newCanvasWidth;
  gameArea.canvas.height = 300;
  gameArea.y = 300;

  if (type === 'resize') {
    score.x = newCanvasWidth / 2;
    score.size = SCORE_SIZE * (score.x * 2);
    score.headlineSize = HEADLINE_SIZE * (score.x * 2);
  }
}

function debounce(func, wait, immediate) {
	let timeout;
	return function() {
		let context = this;
    let args = arguments;
		let later = function() {
			timeout = null;
			if (!immediate) func.apply(context, args);
		};
		let callNow = immediate && !timeout;
		clearTimeout(timeout);
		timeout = setTimeout(later, wait);
		if (callNow) func.apply(context, args);
	};
};

let totalAssets = 0;
let loadedAssets = 0;
let images = new Array();

let ground;
let clouds;
let skyline;
let runner;
let score;
let obstaclesArray = new Array();

function endScreen() {
  gameArea.context.font = '15px GameFont';
  gameArea.context.fillStyle = 'black';
  gameArea.context.textAlign = 'center';
  gameArea.context.fillText('this.text', 300, 60);
}

function assetLoaded() {
  loadedAssets++;
  splashScreen = true;
  if (loadedAssets === totalAssets) {
    window.addEventListener('keydown', e => {
      if(e.keyCode == 32) {
        e.preventDefault();
        hideSplashscreen(splashScreen);
      }
    });
    window.addEventListener('touchstart', hideSplashscreen);

    let myEfficientFn = debounce(function() {
    	setCanvasWidth('resize');
      window.cancelAnimationFrame(myReq);
      animate();
    }, 250);
    window.addEventListener('resize', myEfficientFn);
  }
}

function hideSplashscreen(e) {
  if(document.getElementById('splashScreen')) {
    document.getElementById('splashScreen').style.display = 'none';
  }

  if(splashScreen === true) {
    splashScreen = false;
    document.getElementById('minigame').style.display = 'block';
    startGame();
  }
}

function loadFont(){
  let head = document.getElementsByTagName('head')[0];

  let newStyle = document.createElement('link');
  newStyle.href = 'https://fonts.googleapis.com/css?family=Press+Start+2P';
  newStyle.rel = 'stylesheet';

  document.head.appendChild(newStyle);
}

function preloader() {
  // counter
  var i = 0;
  // set image list
  let urls = new Array();
  urls[0] = 'http://i1.adis.ws/i/sportscheck/minigame_ground';
  urls[1] = 'http://i1.adis.ws/i/sportscheck/minigame_clouds';
  urls[2] = 'http://i1.adis.ws/i/sportscheck/minigame_skyline';
  urls[3] = 'http://i1.adis.ws/i/sportscheck/minigame_runner_sprite';
  urls[4] = 'http://i1.adis.ws/i/sportscheck/minigame_fire_sprite';

  totalAssets = urls.length;

  // start preloading
  for(var i = 0; i < totalAssets; i++) {
    images[i] = new Image();
    images[i].onload = function() {
      assetLoaded();
    }
    images[i].src = urls[i];
  }

  loadFont();
}

function crash(runner, obstacle) {
  var runnerLeft = runner.x;
  var runnerRight = runner.x + (runner.frameWidth);
  var runnerTop = runner.y;
  var runnerBottom = runner.y + runner.dy + (runner.frameHeight);
  var obstacleLeft = obstacle.x;
  var obstacleRight = obstacle.x + (obstacle.frameWidth);
  var obstacleTop = obstacle.y;
  var obstacleBottom = obstacle.y + (obstacle.frameHeight);
  if ((runnerRight < obstacleLeft) || (runnerLeft > obstacleRight) || (runnerBottom < obstacleTop)) {
     return;
  }
  isCrashed = true;
}

function animate() {
   myReq = window.requestAnimationFrame(animate);

   gameArea.context.clearRect(0, 0, gameArea.canvas.width, gameArea.canvas.height);

   obstaclesArray.forEach((obstacle) => {
     crash(runner, obstacle);
   });


   skyline.draw();
   clouds.draw();
   ground.draw();

   if (isCrashed) {
     runner.crash();
   }
   runner.update();
   runner.draw();

   createObstacles();

   obstaclesArray.forEach((obstacle) => {
     obstacle.update();
     obstacle.draw();

     let obstacleNo = obstaclesArray.length;

     if (obstacleNo > 5) {
       for (i = 0; i < obstacleNo - 2; i++) {
         obstaclesArray.shift();
       }
     }
   });

   score.update();

   if (isCrashed) {
     runner.level = 0;
     runner.reset();
     ground.speed = GROUND_SPEED;
     obstacleSpeed = GROUND_SPEED;
     score.done();
     gameArea.stop();
     splashScreen = true;
   }

   gameArea.frameNo++;
   if (gameArea.frameNo % 500 === 0) {
     nextLevel();
   }
}

function createObstacles() {
  if (gameArea.frameNo == 1 || (gameArea.frameNo / 130 % 1 == 0)) {
    const randomFactor = Math.floor(Math.random() * (100 - 1) + 1);
    if (randomFactor % 2 === 0) {
      obstaclesArray.push(new Obstacle(images[4], obstacleSpeed, 600 + randomFactor));
    }
  }
}

function updateSpeed(obstacles, newSpeed) {
  for (i = 0; i < obstacles.length; i++) {
    obstacles[i].speed = newSpeed;
  }
}

function nextLevel() {
  level += 1;
  runner.nextLevel(level);
  ground.speed = GROUND_SPEED + level / 2;
  obstacleSpeed = GROUND_SPEED + level / 2;
  updateSpeed(obstaclesArray, obstacleSpeed);
}

function startGame() {
  if (initalStart) {
    initalStart = false;

    gameArea.start();

    skyline = new Background(images[2], 0.3, 0, 40);
    clouds = new Background(images[1], 0.6, 0, 40);
    ground = new Background(images[0], GROUND_SPEED, 0, 280);
    runner = new Runner(images[3], level);
    score = new Score();
  } else {
    gameArea.frameNo = 0;
    obstaclesArray = [];
    isCrashed = false;
    level = 0;
    runner.reset();
  }

  animate();
}

preloader();
